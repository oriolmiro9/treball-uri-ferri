from bsky import get_feed, get_thread, Thread, Post, Repost
from graph_tool.all import Graph, graph_draw, Vertex
from typing import Dict, Union, Optional, List
import re

def _count_replies(thread: Thread) -> int:
    """
    Compta totes les respostes recursivament d’un thread, incloses les respostes a respostes, i així successivament.
    S'utilitza en ocasions on volem explorar tant sols els posts amb més respostes.
    """
    return sum(1 + _count_replies(r) for r in thread.replies)


def _get_post_uri(item: Union[Post, Repost]) -> Optional[str]:
    """
    Donat un item del Feed de l'usuari, extreu l'uri del post original tenint en compte que pot ser un Post o un Repost.
    """
    if isinstance(item, Repost):
        return item.post.uri
    elif isinstance(item, Post):
        return item.uri
    else:  # cas que no hauria de passar
        return None


def _get_client_threads(client_handle: str, limit: int = 500) -> List[Thread]:
    """
    A partir del handle d'un usuari de Bluesky obté cada thread del fil d'un Usuari.
    Retorna una llista d'aquests Threads.
    """
    threads: List[Thread] = []
    posts = get_feed(client_handle, limit=limit)

    for item in posts:
        post_uri = _get_post_uri(item)
        if not post_uri:  # cas que no hauria de passar
            continue
        try:
            thread = get_thread(post_uri)
            threads.append(thread)
        except Exception as e:
            print(f"Error amb {post_uri}: {e}")
    return threads


def _build_interaction_graph(threads: List[Thread]) -> Graph:
    """
    A partir d'una llista de Thread d'un usuari de Bluesky, es construeix un graf dirigit que representa
    les interaccions entre usuaris on cada usuari és un node. Cada resposta genera una aresta de l'autor original
    cap a l'usuari a qui ha respost. Si dos usuaris interactuen més d'una vegada, s'incrementa el pes de l'aresta.
    """
    graph = Graph(directed=True)
    user_prop = graph.new_vertex_property("string")
    weight_prop = graph.new_edge_property("int")
    user_to_vertex: Dict[str, Vertex] = {}

    def _get_vertex(handle: str) -> Vertex:
        if handle not in user_to_vertex:
            v: Vertex = graph.add_vertex()
            user_prop[v] = handle
            user_to_vertex[handle] = v
        return user_to_vertex[handle]

    def _explore_thread_and_add_edges(t: Thread) -> None:
        post_author_v: Vertex = _get_vertex(t.post.author.handle)
        for reply in t.replies:
            reply_author_v: Vertex = _get_vertex(reply.post.author.handle)
            # Evita arestes d'autoresposta
            if post_author_v == reply_author_v:
                _explore_thread_and_add_edges(reply)
                continue
            edge = graph.edge(post_author_v, reply_author_v)
            if edge is None:
                edge = graph.add_edge(post_author_v, reply_author_v)
                weight_prop[edge] = 1
            else:
                weight_prop[edge] += 1
            _explore_thread_and_add_edges(reply)

    for thread in threads:
        _explore_thread_and_add_edges(thread)

    graph.vertex_properties["user"] = user_prop
    graph.edge_properties["weight"] = weight_prop
    print(f"Nodes: {graph.num_vertices()}, Arestes: {graph.num_edges()}")
    return graph


def get_interaction_graph(username: str, limit: int = 500) -> None:
    """
    Donat el handle d'un usuari de Bluesky, construeix un graf que representa les interaccions entre
    usuaris en el feed del usuari inicial. Llavors, el dibuixa i el desa al Directori.
    """
    # Neteja el handle d'usuari
    username = username.strip()
    username = re.sub(r'[\s\u200e\u200f\u202a-\u202e\u2066-\u2069]+', '', username)
    threads: List[Thread] = _get_client_threads(username, limit=limit)
    if not threads:
        print("Cap thread amb respostes trobat.")
        return
    graph: Graph = _build_interaction_graph(threads)
    user_prop = graph.vertex_properties["user"]
    graph_draw(
        graph,
        vertex_fill_color="skyblue",
        vertex_shape="circle",
        vertex_size=8,  # nodes més petits
        edge_color="black",
        edge_pen_width=1.2,  # arestes més fines
        output_size=(1800, 1800),  # imatge més gran per més claredat
        bg_color="white",
        output=f"{username}_threads.svg",
    )
    print(f"Graf guardat: '{username}_threads.svg'")
    graph.save(f"{username}_threads.gt")


def main():
    username = input("Introdueix el handle de l'usuari (ex: user.bsky.social): ")
    get_interaction_graph(username, limit=500)


if __name__ == "__main__":
    main()
